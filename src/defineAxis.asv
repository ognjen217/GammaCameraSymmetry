function [slope, intercept] = defineAxis(I, ax, fig)
% DEFINEAXIS  Interaktivni izbor ose (klikovi) + fit prave.
% Robusno za uifigure/UIAxes: koristi WindowButtonDownFcn (ne ButtonDownFcn).

    if nargin < 3 || isempty(fig)
        fig = ancestor(ax,'figure');
    end

    % --- Prikaz slike na zadatoj osi ---
    imshow(I, [], 'Parent', ax);
    axis(ax,'ij'); axis(ax,'image');

    % Interakcije/toolbar: ugasi koliko može, ali ne pucaj ako ne može.
    try, disableDefaultInteractivity(ax); catch, end
    try
        if isprop(ax,'Toolbar') && ~isempty(ax.Toolbar)
            ax.Toolbar.Visible = 'off';
        end
    catch
    end
    try
        if isprop(ax,'Interactions')
            ax.Interactions = [];
        end
    catch
    end

    % --- Stanje i grafički objekti ---
    ptsX = []; ptsY = [];
    hold(ax,'on');
    hPts  = plot(ax, NaN, NaN, 'go', 'MarkerFaceColor','g', 'MarkerSize',5, 'PickableParts','none');
    hSkic = plot(ax, NaN, NaN, 'g--', 'LineWidth',1, 'PickableParts','none');
    hLine = plot(ax, NaN, NaN, 'r-',  'LineWidth',2, 'PickableParts','none');
    hold(ax,'off');

    title(ax, 'Levi klik: tačka   |   Desni klik / Enter: kraj i fit linije');

    % --- Hook-ovi na figure (radi i za UIAxes) ---
    oldWBD = [];
    oldWKP = [];
    if isprop(fig,'WindowButtonDownFcn')
        oldWBD = fig.WindowButtonDownFcn;
    end
    if isprop(fig,'WindowKeyPressFcn')
        oldWKP = fig.WindowKeyPressFcn;
    end
    c = onCleanup(@()restoreCallbacks(fig, oldWBD, oldWKP));

    doneFlag = false;

    % postavi globalne callback-ove na fig (siguran način za UIAxes)
    if isprop(fig,'WindowButtonDownFcn')
        fig.WindowButtonDownFcn = @(src,ev) onFigClick(src,ev);
    end
    if isprop(fig,'WindowKeyPressFcn')
        fig.WindowKeyPressFcn   = @(src,ev) onKey(src,ev);
    end

    % blokiraj dok se ne završi izbor
    uiwait(fig);

    % --- Izračun parametara ose ---
    if numel(ptsX) < 2
        slope = 0;
        intercept = size(I,1)/2;   % fallback: horizontalna sredina
    else
        p = polyfit(ptsX, ptsY, 1); % y = m x + b
        slope = p(1);
        intercept = p(2);
    end

    % Nacrtaj isečenu ose (ako handle i dalje postoji)
    [xseg,yseg] = clipLineToImage(slope, intercept, size(I));
    if isvalidSafe(hLine)
        try set(hLine,'XData',xseg,'YData',yseg); catch, end
    end

    % ================== UGNJEŽĐENE FUNKCIJE ==================
    function onFigClick(~, ev)
        % Reaguj samo ako klik pada na dati ax
        try
            h = hittest(fig);
            if isempty(h) || isempty(ancestor(h,'matlab.ui.control.UIAxes'))
                return;
            end
            axHit = ancestor(h,'matlab.ui.control.UIAxes');
            if axHit ~= ax, return; end
        catch
            % Ako je hittest nedostupan, ipak pokušaj sa CurrentPoint
        end

        % Koje dugme?
        btn = 1;
        try
            if isprop(ev,'Button'), btn = ev.Button; end
        catch
        end

        % Uhvati koordinatu u osama
        cp = ax.CurrentPoint;
        x  = cp(1,1);  y = cp(1,2);
        xl = xlim(ax); yl = ylim(ax);
        inside = x>=xl(1) && x<=xl(2) && y>=yl(1) && y<=yl(2);
        if ~inside, return; end

        if btn == 1
            % levi klik => dodaj tačku
            ptsX(end+1) = x;
            ptsY(end+1) = y;
            if isvalidSafe(hPts)
                try set(hPts,'XData',ptsX,'YData',ptsY); catch, end
            end
            if numel(ptsX) >= 2
                p = polyfit(ptsX, ptsY, 1);
                [xs,ys] = clipLineToImage(p(1), p(2), size(I));
                if isvalidSafe(hSkic), try set(hSkic,'XData',ptsX,'YData',ptsY); catch, end, end
                if isvalidSafe(hLine), try set(hLine,'XData',xs,'YData',ys);   catch, end, end
            end
        elseif btn == 3
            % desni klik => kraj
            if ~doneFlag
                doneFlag = true;
                safeUiresume(fig);
            end
        end
    end

    function onKey(~,ev)
        % Enter / Return / Escape -> završi
        try key = ev.Key; catch, key = ''; end
        if any(strcmpi(key, {'return','enter','escape'}))
            if ~doneFlag
                doneFlag = true;
                safeUiresume(fig);
            end
        end
    end
end

% ----------------- HELPERS -----------------
function restoreCallbacks(fig, oldWBD, oldWKP)
    try
        if isprop(fig,'WindowButtonDownFcn')
            fig.WindowButtonDownFcn = oldWBD;
        end
        if isprop(fig,'WindowKeyPressFcn')
            fig.WindowKeyPressFcn   = oldWKP;
        end
    catch
    end
end

function tf = isvalidSafe(h)
    tf = ~isempty(h) && isgraphics(h) && isvalid(h);
end

function safeUiresume(fig)
    try
        if strcmp(get(fig,'Waiting'),'on')
            uiresume(fig);
        end
    catch
    end
end

function [xseg,yseg] = clipLineToImage(slope, intercept, imgSize)
    % Lokalna kopija (isti algoritam kao u GUI-u).
    H = imgSize(1); W = imgSize(2);
    m = slope; b = intercept;

    pts = [];
    y1 = m*1 + b;   if y1>=1 && y1<=H, pts(end+1,:) = [1, y1]; end %#ok<AGROW>
    yW = m*W + b;   if yW>=1 && yW<=H, pts(end+1,:) = [W, yW]; end %#ok<AGROW>
    if abs(m) > eps
        x1 = (1 - b)/m;  if x1>=1 && x1<=W, pts(end+1,:) = [x1, 1]; end %#ok<AGROW>
        xH = (H - b)/m;  if xH>=1 && xH<=W, pts(end+1,:) = [xH, H]; end %#ok<AGROW>
    else
        y = b; if y>=1 && y<=H, pts = [1,y; W,y]; end
    end
    if ~isempty(pts)
        pts = round(pts,6);
        [~, ia] = unique(pts,'rows','stable'); pts = pts(ia,:);
        if size(pts,1) > 2
            D = squareform(pdist(pts));
            [~,ij] = max(D(:)); [i,j] = ind2sub(size(D),ij); pts = pts([i j],:);
        end
    end
    if size(pts,1) < 2
        xseg = [1 W]; yseg = [m*1+b, m*W+b];
    else
        xseg = pts(:,1)'; yseg = pts(:,2)';
    end
end
